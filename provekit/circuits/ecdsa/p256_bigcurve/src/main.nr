use bigcurve::{
    BigCurve,
    curves::secp256r1::{Secp256r1, Secp256r1_Fq, Secp256r1_Fr, Secp256r1Scalar},
};
use bignum::BigNum;

fn main(hashed_message: [u8; 32], pub_key_x: [u8; 32], pub_key_y: [u8; 32], signature: [u8; 64]) {
    let gen = Secp256r1::one();
    let public = Secp256r1::from_coordinates(
        Secp256r1_Fq::from_be_bytes(pub_key_x),
        Secp256r1_Fq::from_be_bytes(pub_key_y),
        false,
    );
    public.validate_on_curve();
    let message = Secp256r1_Fr::from_be_bytes(hashed_message);

    let mut r: [u8; 32] = [0; 32];
    let mut s: [u8; 32] = [0; 32];
    for i in 0..32 {
        r[i] = signature[i];
        s[i] = signature[i + 32];
    }
    let r = Secp256r1_Fr::from_be_bytes(r);
    let s = Secp256r1_Fr::from_be_bytes(s);

    let s_g = Secp256r1Scalar::from_bignum(message / s);
    let s_p = Secp256r1Scalar::from_bignum(r / s);
    let r_point = Secp256r1::evaluate_linear_expression([gen, public], [s_g, s_p], []);

    let x_fr = Secp256r1_Fr::from_be_bytes(r_point.x.to_be_bytes());
    assert(x_fr == r);
}
