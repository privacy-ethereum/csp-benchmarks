use ::circuit::RecursiveCircuit;
use bin::executor::{prove as expander_prove, verify as expander_verify};
use circuit_std_rs::sha256::m31::sha256_var_bytes;
use expander_compiler::circuit::layered::witness::Witness;
use expander_compiler::frontend::*;
use gkr::Verifier;
use gkr_engine::GKREngine;
use gkr_engine::GKRScheme;
use gkr_engine::M31x1Config;
use gkr_engine::MPIConfig;
use gkr_engine::MPIEngine;
use gkr_engine::MPISharedMemory;
use gkr_engine::Proof;
use gkr_hashers::SHA256hasher;
use mersenne31::M31;
use mersenne31::M31Ext3;
use poly_commit::OrionPCSForGKR;
use serdes::ExpSerde;
use std::io::Cursor;
use transcript::BytesHashTranscript;

// Constants and circuit definition
const OUTPUT_LEN: usize = 32; // SHA-256 digest length

// Includes the circuits that were generated by '../build.rs'
include!(concat!(env!("OUT_DIR"), "/sha256_sizes.rs"));

// M31SingleConfig is a configuration for the M31 without SIMD (i.e. no parallel proving in Expander).
#[derive(Default, Debug, Clone, PartialOrd, Ord, Hash, PartialEq, Eq, Copy)]
pub struct M31SnglConfig<'a> {
    _marker: std::marker::PhantomData<&'a ()>,
}

impl<'a> GKREngine for M31SnglConfig<'a> {
    type FieldConfig = M31x1Config;
    type MPIConfig = MPIConfig<'a>;
    type TranscriptConfig = BytesHashTranscript<SHA256hasher>;
    type PCSConfig = OrionPCSForGKR<M31x1Config, M31>;
    const SCHEME: GKRScheme = GKRScheme::Vanilla;
}

pub type M31SingleConfig = M31SnglConfig<'static>;

impl Config for M31SingleConfig {
    const CONFIG_ID: usize = 1;
}

// Inspired by https://github.com/PolyhedraZK/ExpanderCompilerCollection/blob/cc12748abcf043c5912b36d3341e5be51b1dca61/circuit-std-rs/src/sha256/m31.rs#L515
pub fn check_sha256_var<C: Config, B: RootAPI<C>>(
    api: &mut B,
    data: &[Variable], //  msg â€– digest
) -> Vec<Variable> {
    let msg_len = data.len() - OUTPUT_LEN;
    let expected = data[msg_len..].to_vec();
    let computed = sha256_var_bytes(api, &data[..msg_len]);

    for i in 0..OUTPUT_LEN {
        api.assert_is_equal(computed[i], expected[i]);
    }
    computed
}

pub fn prove(
    circuit_bytes: &[u8],
    witness_bytes: &[u8],
    mpi_config: MPIConfig<'_>,
) -> (M31Ext3, Proof) {
    // Taken from Circuit::prover_load_circuit
    let circuit_opt = if mpi_config.is_root() {
        let rc: RecursiveCircuit<M31x1Config> =
            RecursiveCircuit::deserialize_from(Cursor::new(circuit_bytes)).unwrap();
        let circuit = rc.flatten();
        Some(circuit)
    } else {
        None
    };

    let (mut circuit, mut window) = mpi_config.consume_obj_and_create_shared(circuit_opt);
    circuit.pre_process_gkr();

    // Taken from circuit.prover_load_witness_file
    circuit.load_witness_bytes(witness_bytes, &mpi_config, true, false);

    let proof = expander_prove::<M31SingleConfig>(&mut circuit, mpi_config.clone());

    // Clean up shared memory
    circuit.discard_control_of_shared_mem();
    mpi_config.free_shared_mem(&mut window);

    proof
}

pub fn verify(
    circuit_bytes: &[u8],
    witness_bytes: &[u8],
    proof: &Proof,
    claimed_v: &M31Ext3,
    mpi_config: MPIConfig<'_>,
) {
    // Taken from Circuit::verifier_load_circuit
    let rc: RecursiveCircuit<M31x1Config> =
        ExpSerde::deserialize_from(Cursor::new(circuit_bytes)).unwrap();
    let mut circuit = rc.flatten();
    circuit.pre_process_gkr();

    // Load witness from bytes for verifier
    circuit.load_witness_bytes(witness_bytes, &mpi_config, false, false);

    let verifier = Verifier::<M31SingleConfig>::new(mpi_config);
    assert!(expander_verify::<M31SingleConfig>(
        &mut circuit,
        verifier.mpi_config,
        proof,
        claimed_v
    ));
}

// Macro generating a match arm that prepares the circuit and witness for the given input size
macro_rules! prepare_arm {
    ($Circuit:ident, $LEN:expr) => {{
        let compile_result =
            compile(&$Circuit::<Variable>::default(), CompileOptions::default()).unwrap();

        const LEN: usize = $LEN;
        let (message_bytes, output) = utils::generate_sha256_input(LEN);

        let mut assignment = $Circuit::<M31>::default();
        for (i, input_byte) in message_bytes.iter().enumerate().take(LEN) {
            assignment.input[i] = M31::from(*input_byte as u32);
        }
        for i in 0..OUTPUT_LEN {
            assignment.output[i] = M31::from(output[i] as u32);
        }

        let witness = compile_result
            .witness_solver
            .solve_witness_with_hints(&assignment, &EmptyHintCaller)
            .unwrap();

        serialize_outputs(compile_result, witness)
    }};
}

fn serialize_outputs(
    compile_result: CompileResult<M31SingleConfig>,
    witness: Witness<M31SingleConfig>,
) -> (Vec<u8>, Vec<u8>) {
    let mut circuit_bytes = Vec::new();
    compile_result
        .layered_circuit
        .serialize_into(&mut circuit_bytes)
        .unwrap();

    let mut witness_bytes = Vec::new();
    witness.serialize_into(&mut witness_bytes).unwrap();

    (circuit_bytes, witness_bytes)
}

/// Prepare the circuit and witness for the given input size
/// (invokes `match` for all input sizes that was generated by `../build.rs`)
pub fn prepare(input_len: usize) -> (Vec<u8>, Vec<u8>) {
    match_sha2_sizes!(input_len, prepare_arm)
}
